package com.teamtreehouse.model;

import java.util.*;
import java.util.stream.Collectors;

// Team implements comparable, so that we can compare teams in Set
// in prompter, so that administrator can see list of available teams
public class Team implements Comparable<Team> {
    // max number of players constant
    public static final int MAX_NUMBER_OF_PLAYERS = 11;

    // is used is testing to check whether team is full
    protected boolean isFull() {
        if (mPlayersSet.size() == MAX_NUMBER_OF_PLAYERS) {
            return true;
        } else {
            return false;
        }
    }

    // primary collection of players, ensures that players are unique
    public Set<Player> getPlayersSet() {
        return mPlayersSet;
    }
    private Set<Player> mPlayersSet;

    private String mName;
    public String getName() {
        return mName;
    }

    // later is used in prompter to set it, otherwise rather unusable
    private String mCoachName;

    // only name and coach are displayed... when team is printed
    // The players set of team is presented separately
    @Override
    public String toString() {
        return " Name: '" + mName + "', Coach: '" + mCoachName + "'";
    }

    // default constructor used everywhere
    public Team(String name, String coachName) {
        mName = name;
        mCoachName = coachName;
        mPlayersSet = new TreeSet<>();
    }
    // now used only in testing
    protected int getTeamSize() {
        return mPlayersSet.size();
    }

    // add player, reuses Set's add ,method, but also returns false
    // when there are more than MAX_NUMBER_OF_PLAYERS
    public boolean addPlayer(Player player) {
       if (mPlayersSet.size() < MAX_NUMBER_OF_PLAYERS) {
           return mPlayersSet.add(player);
       } else {
           return false;
       }
    }
    // reuses Set's remove
    public boolean remove(Player player) {
        return mPlayersSet.remove(player);
    }

    // Get the Set of heights of player in team, used in
    // getListOfNumberOfPlayersWithSpecificHeight
    private Set<Integer> getSetOfPlayerHeights() {
        return mPlayersSet
                .stream()
                .map(Player::getHeightInInches)
                .collect(Collectors.toCollection(TreeSet::new));
    }

    // this methods takes tree set of height Integers from method
    // getSetOfPlayerHeights() and creates Map<Integer,Integer> of
    // "'height' : '# of players with this height'"
    // that will help to show the distribution of height throughout the team
    // and other teams
    // @return Map<Integer,Integer> map with heights to number of players
    public Map<Integer,Integer> getMapOfNumberOfPlayersWithSpecificHeight() {
        // tree map is used
        Map<Integer,Integer> mapOfPlayersWithSpecificHeight = new TreeMap<>();
        // get unique set of heights
        for (Integer height: getSetOfPlayerHeights()) {
            int numberOfPlayersWithThisHeight = 0;
            // calculate # of players with this height
            for (Player player : mPlayersSet) {
                if (player.getHeightInInches() == height) {
                    numberOfPlayersWithThisHeight++;
                }
            }
            // put number of players this high with height key to map
            mapOfPlayersWithSpecificHeight
                    .put(height,numberOfPlayersWithThisHeight);
        }
        return mapOfPlayersWithSpecificHeight;
    }

    // maps experience level String : 'experienced' or 'beginner'
    // to Integer # of players with that experience
    // @return Map<String,Integer> : experience level to # of players
    public Map<String,Integer> getMapOfPlayersWithDifferentExperience() {
        // tree map is used
        Map<String,Integer> mapOfExperienceLevelToNumberOfPlayers =
                new TreeMap<>();
        int numberOfExperiencedPlayers = 0;
        // calculate players who has experience
        for (Player player : mPlayersSet) {
            if (player.hasPreviousExperience()) {
                numberOfExperiencedPlayers++;
            }
        }
        // put # of experienced players to map
        mapOfExperienceLevelToNumberOfPlayers
                .put("Experienced",numberOfExperiencedPlayers);
        // put # of beginners to map, by subtracting # of players from
        // number of experienced players
        mapOfExperienceLevelToNumberOfPlayers
                .put("Beginner",
                        mPlayersSet.size() - numberOfExperiencedPlayers);
        return mapOfExperienceLevelToNumberOfPlayers;
    }

    // automatically generated by IDE
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Team team = (Team) o;

        if (mPlayersSet != null ? !mPlayersSet.equals(team.mPlayersSet) : team.mPlayersSet != null)
            return false;
        if (mName != null ? !mName.equals(team.mName) : team.mName != null)
            return false;
        return mCoachName != null ? mCoachName.equals(team.mCoachName) : team.mCoachName == null;

    }

    // automatically generated by IDE
    @Override
    public int hashCode() {
        int result = mPlayersSet != null ? mPlayersSet.hashCode() : 0;
        result = 31 * result + (mName != null ? mName.hashCode() : 0);
        result = 31 * result + (mCoachName != null ? mCoachName.hashCode() : 0);
        return result;
    }

    // We compare only team names, different coaches can't train one team,
    // so that we can show them alphabetically sorted by name
    @Override
    public int compareTo(Team otherTeam) {
        if (this.equals(otherTeam)) {
            return 0;
        }
        return mName.compareTo(otherTeam.mName);
    }

    // this method simply uses Set.contains() method, but is here to
    // be called from Team class, to hide implementation details..
    // Hope its a good policy
    public boolean contains(Player player) {
        return mPlayersSet.contains(player);
    }

    public String getCoachName() {
        return mCoachName;
    }

    // simply hide Set.size() to team.size()
    public int size() {
        return mPlayersSet.size();
    }

}
